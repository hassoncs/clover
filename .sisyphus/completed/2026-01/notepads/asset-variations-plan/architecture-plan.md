# Asset Sheet Architecture - Comprehensive Plan

**Generated by:** ultrabrain planning agent  
**Session:** ses_4113e03ffffeud72Q9MYI01p9C  
**Date:** 2026-01-23

---

## Executive Summary

Treat **everything that is "one image containing many usable sub-images"** as a single `AssetSheet` (atlas PNG + deterministic metadata JSON). Sprite sheets, tile sheets, and variation sheets become three `kind`s over the same core model, and `AssetPackV2` binds templates to either a single `GameAsset` or a `sheet entry` within an `AssetSheet`.

---

## 1) Data Model - Core Concept

```
AssetSheet = atlas PNG + layout + entries + per-kind semantics
```

The atlas PNG is stored as a normal `GameAsset`. The sheet metadata references the image by `assetId`.

### TypeScript Types (new file: `shared/src/types/asset-sheet.ts`)

```typescript
export type AssetSheetKind = "sprite" | "tile" | "variation";

// Layout options
export type SheetLayout =
  | { type: "grid"; columns: number; rows: number; cellWidth: number; cellHeight: number; spacing?: number; margin?: number; origin?: "top-left" }
  | { type: "strip"; direction: "horizontal" | "vertical"; frameCount: number; cellWidth: number; cellHeight: number; spacing?: number; margin?: number; }
  | { type: "manual"; }; // entries must provide explicit rects

// How to address a region within the atlas
export type SheetRegion =
  | { type: "gridIndex"; index: number } // 0..(columns*rows-1), row-major
  | { type: "rect"; x: number; y: number; w: number; h: number };

// Shared "named region" that sprite/tile/variation all use
export interface AssetSheetEntry {
  id: string;              // stable key (e.g. "run_0", "brick/red", "tile:17")
  region: SheetRegion;
  pivot?: SheetPivot;      // for consistent anchoring in-engine
  tags?: string[];
}

// Sprite semantics
export interface SheetAnimation {
  id: string;              // "idle", "run", "explode"
  frames: string[];        // array of AssetSheetEntry.id
  fps: number;
  loop?: boolean;
}

// Tile semantics
export interface TileMetadata {
  name?: string;
  tags?: string[];
  collision?: "none" | "full" | "platform" | { polygon: { x: number; y: number }[] };
  animation?: { frames: number[]; fps: number; loop?: boolean };
}

// Variation semantics
export interface VariationGroup {
  id: string; // usually the semantic "thing": "brick", "peg", "gem"
  variants: Record<
    string, // variantKey: "red", "blue", "ice", "gold"
    { entryId: string; tags?: string[]; weight?: number }
  >;
}

// The main AssetSheet type (discriminated union)
export type AssetSheet =
  | (AssetSheetBase & { kind: "sprite"; animations?: Record<string, SheetAnimation>; defaultAnimationId?: string; })
  | (AssetSheetBase & { kind: "tile"; tileWidth: number; tileHeight: number; tiles?: Record<number, TileMetadata>; })
  | (AssetSheetBase & { kind: "variation"; groups: Record<string, VariationGroup>; defaultGroupId?: string; defaultVariantKey?: string; });
```

### Binding Model (how templates pick pixels)

```typescript
export type AssetBinding =
  | { type: "image"; assetId: string }
  | {
      type: "sheetEntry";
      sheetId: string;
      entryId: string;
      animationId?: string;       // for sprite
      variationGroupId?: string;  // for variation
      variantKey?: string;        // for variation
    };
```

---

## 2) Prompt Strategy

### Key Rule
**Prompt for layout + consistency; never rely on the model to infer your grid.** Metadata is deterministic and comes from your declared layout.

### Sprite Sheet Prompt Template
```txt
=== CAMERA/VIEW (CRITICAL) ===
FRONT VIEW. Flat 2D. No perspective. Consistent camera and scale in every frame.

=== OUTPUT FORMAT (CRITICAL) ===
A SPRITE SHEET (single image) arranged as a 4 columns x 2 rows grid.
Each cell is 128x128 pixels with 8px empty padding between cells.
NO borders, NO grid lines, NO labels, NO text.

=== SUBJECT ===
[entity description], game sprite, [theme/style].

=== FRAMES (CRITICAL) ===
Row 1 (left to right): idle_0, idle_1, run_0, run_1
Row 2 (left to right): run_2, run_3, jump_0, jump_1
Same character, same colors, same outfit, consistent lighting.

=== TECHNICAL ===
Transparent background (alpha channel).
Single sprite per cell, centered.
No duplicates, no cropping, no watermark.
```

### Variation Sheet Prompt Template (e.g., breakout bricks)
```txt
=== OUTPUT FORMAT (CRITICAL) ===
A VARIATION SHEET (single image) arranged as a 6 columns x 1 row grid.
Each cell is 64x32 pixels with 6px spacing. NO borders/labels/text.

=== SUBJECT (CRITICAL) ===
The exact same brick shape in every cell: same silhouette, bevel, outline thickness, and lighting.
Only the COLOR MATERIAL changes per cell.

=== VARIANTS ===
Left to right: red, orange, yellow, green, blue, purple.

=== TECHNICAL ===
Transparent background (alpha).
No grid lines, no numbers, no letters.
```

### Tile Sheet Prompt Template
```txt
=== OUTPUT FORMAT (CRITICAL) ===
A TILESET (single image) arranged as an 8x8 grid.
Each tile is 32x32 pixels. 2px spacing. NO borders/labels/text.

=== CONTENT ===
A cohesive set of platformer tiles: ground, edges, corners, decorative variants.
Consistent palette, consistent lighting, seamless edges.

=== TECHNICAL ===
Pixel art. No anti-aliasing. Transparent background where appropriate.
No grid lines.
```

### Recommended: Use img2img "sheet guide" image
- Generate a guide PNG with grid geometry (and optionally faint silhouette in each cell for variations)
- Run img2img against guide with strength 0.7-0.85
- Prompt still forbids grid lines; guide should not "print through"

---

## 3) Pipeline Design

### Pipeline Type Additions
```typescript
export type AssetType = "entity" | "background" | "title_hero" | "parallax" | "sheet";
export type SheetKind = "sprite" | "tile" | "variation";

export interface SheetSpecBase {
  type: "sheet";
  id: string;
  kind: SheetKind;
  layout: SheetLayout;
  width?: number;
  height?: number;
  prompt: string;
}

export interface SpriteSheetSpec extends SheetSpecBase {
  kind: "sprite";
  animations: Record<string, { frames: string[]; fps: number; loop?: boolean }>;
}

export interface VariationSheetSpec extends SheetSpecBase {
  kind: "variation";
  variants: Array<{ key: string; description?: string }>;
}

export interface TileSheetSpec extends SheetSpecBase {
  kind: "tile";
  tileWidth: number;
  tileHeight: number;
}
```

### Stage Graph for Sheets
1. `sheet-guide` (new) - produces a PNG guide buffer with grid geometry
2. `build-prompt` - format sheet prompts
3. `upload-scenario` - upload guide (not just silhouette)
4. `img2img` - generate against guide
5. `remove-bg` (optional/fallback)
6. `build-sheet-metadata` (new) - deterministic JSON from spec
7. `upload-r2` - upload both PNG and JSON

### Upload Strategy
- `${r2Prefix}/${spec.id}.png`
- `${r2Prefix}/${spec.id}.sheet.json`

### Metadata is Deterministic
- Never "guess" frame rects from generated pixels
- Rects come from declared layout + entry mapping from spec/editor

---

## 4) Example Sheet JSON

```json
{
  "id": "bricks_v1",
  "packId": "pack_123",
  "kind": "variation",
  "source": "generated",
  "imageAssetId": "asset_abc",
  "imageUrl": "https://.../generated/game/bricks_v1.png",
  "imageWidth": 512,
  "imageHeight": 64,
  "layout": { "type": "grid", "columns": 8, "rows": 1, "cellWidth": 64, "cellHeight": 64, "spacing": 0, "margin": 0 },
  "entries": {
    "brick/red":   { "id": "brick/red",   "region": { "type": "gridIndex", "index": 0 } },
    "brick/blue":  { "id": "brick/blue",  "region": { "type": "gridIndex", "index": 1 } },
    "brick/gold":  { "id": "brick/gold",  "region": { "type": "gridIndex", "index": 2 } }
  },
  "groups": {
    "brick": {
      "id": "brick",
      "variants": {
        "red":  { "entryId": "brick/red" },
        "blue": { "entryId": "brick/blue" },
        "gold": { "entryId": "brick/gold", "weight": 0.2, "tags": ["rare"] }
      }
    }
  }
}
```

---

## 5) File Modification Map

### Shared Types/Schemas
| File | Change |
|------|--------|
| `shared/src/types/asset-sheet.ts` | NEW: TS interfaces/types for AssetSheet, AssetSheetEntry, AssetBinding |
| `shared/src/types/index.ts` | Export new module |
| `shared/src/types/schemas.ts` | Add AssetSheetSchema (+ supporting schemas) |
| `shared/src/types/asset-system.ts` | Integrate AssetBinding into AssetPackEntry |

### API Pipeline
| File | Change |
|------|--------|
| `api/src/ai/pipeline/types.ts` | Add `AssetType: "sheet"` and SheetSpec variants + artifacts |
| `api/src/ai/pipeline/registry.ts` | Add stage list for `"sheet"` |
| `api/src/ai/pipeline/prompt-builder.ts` | Add `buildSheetPrompt(...)` |
| `api/src/ai/pipeline/stages/index.ts` | Add `sheet-guide` and `build-sheet-metadata` stages |

---

## 6) Implementation Sequence (Recommended)

1. **Add shared types/schemas** - AssetSheet, AssetBinding, Zod schemas
2. **Extend pipeline types** - Add sheet spec variants to types.ts
3. **Add sheet guide stage** - Generate grid guide PNG
4. **Add sheet prompt builder** - Format prompts for grids/variations
5. **Add metadata build stage** - Deterministic JSON from spec
6. **Extend upload-r2** - Upload both PNG and JSON
7. **Extend AssetPackV2** - Support sheet binding in entries
8. **Add editor UI** - Allow users to define layout before generation
9. **Add runtime consumption** - Atlas region rendering and animation setup

---

## 7) Risk Mitigation

**Risk:** Background removal can break sheets (removes pixels we need)
**Mitigation:** 
- Prompt for alpha channel explicitly
- Make remove-bg a fallback-only stage for sheets (skip by default)

---

*This plan can be followed with migration-first implementation sequence (small PRs that keep the app working at each step).*
